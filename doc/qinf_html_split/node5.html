<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>4 Creating instances of states</TITLE>
<META NAME="description" CONTENT="4 Creating instances of states">
<META NAME="keywords" CONTENT="qinf">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="qinf.css">

</HEAD>

<BODY text="#000000" bgcolor="#FFFFFF">
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html228"
  HREF="node5.html#SECTION00051000000000000000"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> <B>ketz</B>, <B>braz</B>,<B>ketx</B>, <B>brax</B>,
  <B>kety</B>, <B>bray</B> -- multipartite eigenstate kets and bras of 
 <!-- MATH
 $\sigma_x,\sigma_y,\sigma_z$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="87" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img26.png"
 ALT="$\sigma_x,\sigma_y,\sigma_z$"></SPAN></A>
<LI><A NAME="tex2html229"
  HREF="node5.html#SECTION00052000000000000000"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> <B>ket_n</B>, <B>bra_n</B> --  alternate form of <B>ketz</B>, etc<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
<LI><A NAME="tex2html230"
  HREF="node5.html#SECTION00053000000000000000"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> <B>proj</B> -- Density matrix representation of a pure state (projection operator)<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
<LI><A NAME="tex2html231"
  HREF="node5.html#SECTION00054000000000000000"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> <B>otimes</B>, <B>tensor_product</B>, <B>tensor_power</B>
   -- Creating state vectors with the tensor product<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
<LI><A NAME="tex2html232"
  HREF="node5.html#SECTION00055000000000000000"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> <B>schmidt_ket</B> -- bipartite ket in Schmidt basis<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
<LI><A NAME="tex2html233"
  HREF="node5.html#SECTION00056000000000000000"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> <B>bell</B> and  <B>belln</B> -- Bell state kets in computational basis<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
<LI><A NAME="tex2html234"
  HREF="node5.html#SECTION00057000000000000000"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> <B>ghz</B> and  <B>ghzn</B> -- GHZ state kets<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
<LI><A NAME="tex2html235"
  HREF="node5.html#SECTION00058000000000000000"><SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> <B>werner</B> -- Werner state density matrix<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00050000000000000000">
<SPAN CLASS="arabic">4</SPAN> Creating instances of states</A>
</H1>
Here are some methods for creating instances of states, from scratch or
from other states. Although all operators  `create' states in this
sense, we omit most of them here, because they are better described as manipulating
states.

<H2><A NAME="SECTION00051000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> <B>ketz</B>, <B>braz</B>,<B>ketx</B>, <B>brax</B>,
  <B>kety</B>, <B>bray</B> -- multipartite eigenstate kets and bras of 
 <!-- MATH
 $\sigma_x,\sigma_y,\sigma_z$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="87" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img26.png"
 ALT="$\sigma_x,\sigma_y,\sigma_z$"></SPAN></A>
</H2>
<A NAME="4568"></A><A NAME="4570"></A><A NAME="4572"></A><A NAME="4574"></A><A NAME="4576"></A><A NAME="4578"></A>
<A NAME="2728"></A>
<A NAME="4270"></A>
create normalized <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$n$"></SPAN>-partite product states in the computational basis.
In all cases the indices are <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.png"
 ALT="$0$"></SPAN> or <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img28.png"
 ALT="$1$"></SPAN>. The pair 
<B>ketz</B>(<!-- MATH
 ${i_1,\ldots,i_n}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="86" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img29.png"
 ALT="${i_1,\ldots,i_n}$"></SPAN>) and <B>braz</B>(<!-- MATH
 ${i_1,\ldots,i_n}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="86" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img29.png"
 ALT="${i_1,\ldots,i_n}$"></SPAN>) produce
eigenstates of <!-- MATH
 $\sigma_z^{(1)} \otimes \cdots \otimes \sigma_z^{(n)}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="151" HEIGHT="47" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$\sigma_z^{(1)} \otimes \cdots \otimes \sigma_z^{(n)}$"></SPAN>,
with the index <SPAN CLASS="MATH"><IMG
 WIDTH="52" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$i=0$"></SPAN> selecting the state with eigenvalue <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img28.png"
 ALT="$1$"></SPAN> and
<SPAN CLASS="MATH"><IMG
 WIDTH="52" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.png"
 ALT="$i=1$"></SPAN> selecting the state with eigenvalue <SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$-1$"></SPAN>.
In other words the ket produced represents <!-- MATH
 ${\lvert i_1,i_2,\ldots,i_n \rangle}.$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="131" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="${\lvert i_1,i_2,\ldots,i_n \rangle}.$"></SPAN>
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="137" ALIGN="BOTTOM" BORDER="0"
 SRC="img35.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i3) ketz(1)
\end{verbat...
...\begin{dmath}[number={\%o3}]
\pmatrix{0\cr 1\cr }\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>

<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="118" ALIGN="BOTTOM" BORDER="0"
 SRC="img36.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i4) braz(1)
\end{verbat...
...th}[number={\%o4}]
\pmatrix{0&amp;\linebreak[0]1\cr }\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>

<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="118" ALIGN="BOTTOM" BORDER="0"
 SRC="img37.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i5) braz(0)
\end{verbat...
...th}[number={\%o5}]
\pmatrix{1&amp;\linebreak[0]0\cr }\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
Here are the states <!-- MATH
 ${\langle 00 \rvert},{\langle 11 \rvert},$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="92" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="${\langle 00 \rvert},{\langle 11 \rvert},$"></SPAN> and
<!-- MATH
 $\alpha_0{\langle 00 \rvert} + \alpha_1{\langle 11 \rvert}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="146" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img39.png"
 ALT="$\alpha_0{\langle 00 \rvert} + \alpha_1{\langle 11 \rvert}$"></SPAN>. (we show bras rather than
kets to conserve space)
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="368" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i6) braz(0,0)
\end{verb...
...ak[0]0&amp;\linebreak[0]0&amp;\linebreak[0]\alpha_{1}\cr }\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>

<P>
The functions  <B>ketx</B> <A NAME="4610"></A>,  <B>brax</B> <A NAME="4613"></A>,  <B>kety</B> <A NAME="4616"></A>,  <B>bray</B> <A NAME="4619"></A> produce
eigenstates of <!-- MATH
 $\sigma_x^{(1)} \otimes \cdots \otimes \sigma_x^{(n)}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="151" HEIGHT="47" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$\sigma_x^{(1)} \otimes \cdots \otimes \sigma_x^{(n)}$"></SPAN>,
or <!-- MATH
 $\sigma_y^{(1)} \otimes \cdots \otimes \sigma_y^{(n)}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="151" HEIGHT="47" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$\sigma_y^{(1)} \otimes \cdots \otimes \sigma_y^{(n)}$"></SPAN>,
with, as before, the index <SPAN CLASS="MATH"><IMG
 WIDTH="52" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img31.png"
 ALT="$i=0$"></SPAN> selecting the state with eigenvalue <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img28.png"
 ALT="$1$"></SPAN> and
<SPAN CLASS="MATH"><IMG
 WIDTH="52" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img32.png"
 ALT="$i=1$"></SPAN> selecting the state with eigenvalue <SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$-1$"></SPAN>.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="250" ALIGN="BOTTOM" BORDER="0"
 SRC="img43.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i9) brax(1)
\end{verbat...
...*\sqrt{2}}&amp;\linebreak[0]\frac{i}{2\*\sqrt{2}}\cr }\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>

<P>

<H2><A NAME="SECTION00052000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> <B>ket_n</B>, <B>bra_n</B> --  alternate form of <B>ketz</B>, etc<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
</H2>
<A NAME="4669"></A>, <A NAME="4671"></A>
<B>ket_n</B>(<!-- MATH
 $j,i_1,\ldots,i_m$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="108" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$j,i_1,\ldots,i_m$"></SPAN>) and <B>bra_n</B>(<!-- MATH
 $j,i_1,\ldots,i_m$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="108" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$j,i_1,\ldots,i_m$"></SPAN>)
 are an alternate way to call <B>ketx</B>, <B>kety</B>, etc. The index <SPAN CLASS="MATH"><IMG
 WIDTH="109" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="$j\in(1,2,3)$"></SPAN>
is mapped to <SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$(x,y,z)$"></SPAN> and the appropriate function, eg. <B>ketx</B> is called with
the remaining arguments.

<P>

<H2><A NAME="SECTION00053000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> <B>proj</B> -- Density matrix representation of a pure state (projection operator)<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
</H2>
<A NAME="4679"></A>
The projection operator <A NAME="2830"></A>
<A NAME="2831"></A> (or equivalently, the density
matrix) corresponding to a state vector is generated via the
outer product, which is represented by the dot operator.  A
convenience function <B>proj</B>(<SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img47.png"
 ALT="$ket$"></SPAN>) is also provided to
form a projection operator. The argument <I>ket</I> can be either a bra
or a ket (ie column or row vector). ( <B>proj</B> <A NAME="4684"></A> does not check that
<I>ket</I> is normalized.) Below, we use the <I>Maxima</I> function
 <B>ctranspose</B> <A NAME="4689"></A> for the complex transpose.
Here is the outer product, or dyad<A NAME="2839"></A><A NAME="2840"></A>
<!-- MATH
 ${\lvert 0 \rangle}{\langle 0 \rvert}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.png"
 ALT="${\lvert 0 \rangle}{\langle 0 \rvert}$"></SPAN>.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="139" ALIGN="BOTTOM" BORDER="0"
 SRC="img49.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i19) ketx(1) . brax(1);...
...}{2}\cr -\frac{1}{2}&amp;\linebreak[0]\frac{1}{2}\cr }\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
Compare this to the inner product<A NAME="2856"></A>
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="112" ALIGN="BOTTOM" BORDER="0"
 SRC="img50.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i20) brax(1) . ketx(1);
\end{verbatim}
\begin{dmath}[number={\%o20}]
1\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
Here are different ways to make <!-- MATH
 ${\lvert 000 \rangle}{\langle 000 \rvert}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="98" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="${\lvert 000 \rangle}{\langle 000 \rvert}$"></SPAN> and <!-- MATH
 ${\lvert 101 \rangle}{\langle 101 \rvert}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="98" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="${\lvert 101 \rangle}{\langle 101 \rvert}$"></SPAN>.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="237" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i21) is ( ketz(0,0,0) ....
...atim}
\begin{dmath}[number={\%o22}]
\mathbf{true}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
This example used <I>Maxima</I>'s 
<A NAME="tex2html28"
  HREF="http://maxima.sourceforge.net/docs/manual/en/maxima_5.html#IDX97"><B>is</B>(<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$expr$"></SPAN>)</A><SUP><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$\dagger$"></SPAN></SUP><A NAME="2882"></A>
<A NAME="4720"></A>  function which
tries to determine whether the predicate <I>expr</I> is true or false.

<P>
There is also a function  <B>tovect</B> <A NAME="4724"></A> that
is the inverse (up to a phase) of  <B>proj</B> <A NAME="4727"></A>-- it returns the ket corresponding to a
projection operator. If the input matrix is not a projection operator,
the result is undefined.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="112" ALIGN="BOTTOM" BORDER="0"
 SRC="img55.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i17) is ( tovect( proj(...
...atim}
\begin{dmath}[number={\%o17}]
\mathbf{true}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>

<P>

<H2><A NAME="SECTION00054000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> <B>otimes</B>, <B>tensor_product</B>, <B>tensor_power</B>
   -- Creating state vectors with the tensor product<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
</H2>
<A NAME="4737"></A><A NAME="4739"></A><A NAME="4741"></A>
<A NAME="2899"></A> <A NAME="2900"></A>
The function <B>tensor_product</B>(<!-- MATH
 $v_1,\ldots,v_n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="92" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$v_1,\ldots,v_n$"></SPAN>), returns
<!-- MATH
 $v_1\otimes v_2\cdots\otimes v_n$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="145" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img57.png"
 ALT="$v_1\otimes v_2\cdots\otimes v_n$"></SPAN>, where <SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$v_i$"></SPAN> are vectors
or matrices. The <B>otimes</B> operator is an `infix' operator
that is equivalent to the function <B>tensor_product</B>.
The function <B>tensor_power</B>(<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img59.png"
 ALT="$op,n$"></SPAN>), returns the <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$n$"></SPAN>th
tensor power of the operator <code>op</code>. 
Once again, we will employ the 
<A NAME="tex2html29"
  HREF="http://maxima.sourceforge.net/docs/manual/en/maxima_5.html#IDX97"><B>is</B><SUP><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$\dagger$"></SPAN></SUP></A><A NAME="4753"></A>
 function.
Keep in mind that, in this example, the expressions are not
analyzed abstractly, but rather vectors with integer
elements are generated and compared elementwise.  <BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="388" ALIGN="BOTTOM" BORDER="0"
 SRC="img60.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i12) is (ketz(0,1) = ke...
...atim}
\begin{dmath}[number={\%o14}]
\mathbf{true}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>

<P>

<H2><A NAME="SECTION00055000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> <B>schmidt_ket</B> -- bipartite ket in Schmidt basis<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
</H2>
<A NAME="4761"></A>
<B>schmidt_ket</B>(<SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img61.png"
 ALT="$a$"></SPAN>)creates a ket in the schmidt form. <A NAME="2932"></A> This is
equivalent to <code>sqrt(a)*ket(0,0)+ sqrt(1-a)*ket(1,1)</code>. This
only works for qubits (<SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img62.png"
 ALT="$d=2$"></SPAN>). Note that you may need to
enter <code>assume(a&gt;0,1-a&gt;0)</code><A NAME="4764"></A> when manipulating this state
The <A NAME="tex2html30"
  HREF="http://maxima.sourceforge.net/docs/manual/en/maxima_11.html#IDX381"><B>assume</B></A><SUP><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$\dagger$"></SPAN></SUP>function is used to build
a database of facts used, for instance, by the  <B>is</B> <A NAME="4773"></A> function.

<P>

<H2><A NAME="SECTION00056000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> <B>bell</B> and  <B>belln</B> -- Bell state kets in computational basis<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
</H2>
<A NAME="4777"></A><A NAME="4779"></A>
<A NAME="2941"></A>
create vector bell states. <B>bell[a,b]</B> creates the state
<BR>
<DIV ALIGN="LEFT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
{\lvert\Psi_{a,b} \rangle} = \frac{1}{\sqrt{2}} {\lvert 0,b \rangle} + (-1)^a  {\lvert 1,\bar b \rangle},
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD CLASS="eqno" WIDTH=10 ALIGN="LEFT">
(<SPAN CLASS="arabic">1</SPAN>)</TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="286" HEIGHT="56" BORDER="0"
 SRC="img63.png"
 ALT="\begin{displaymath}
{\lvert\Psi_{a,b} \rangle} = \frac{1}{\sqrt{2}} {\lvert 0,b \rangle} + (-1)^a {\lvert 1,\bar b \rangle},
\end{displaymath}"></TD>
</TR></TABLE>
<BR CLEAR="ALL"></DIV><P></P>
where <SPAN CLASS="MATH"><IMG
 WIDTH="113" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img64.png"
 ALT="$a,b\in\{0,1\}$"></SPAN>. The array <B>belln[i]</B> creates the same states
where <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$i$"></SPAN> is the decimal representation of the binary numeration
<SPAN CLASS="MATH"><IMG
 WIDTH="51" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img65.png"
 ALT="$(a,b)$"></SPAN>. That is, <SPAN CLASS="MATH"><IMG
 WIDTH="92" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$(0,1,2,3)$"></SPAN> corresponds to <!-- MATH
 $( (0,0), (0,1), (1,0), (1,1) )$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="238" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$( (0,0), (0,1), (1,0), (1,1) )$"></SPAN>.
Note that <B>belln[i]</B> is a <I>Maxima</I> 
<A NAME="tex2html31"
  HREF="http://maxima.sourceforge.net/docs/manual/en/maxima_24.html#SEC79"><B>array</B></A><SUP><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$\dagger$"></SPAN></SUP><A NAME="4791"></A> as indicated by the square
brackets.

<P>
As an exercise, we will check our definitions of the Bell
states by testing for orthonormality. <A NAME="2955"></A> We first define an array
function <A NAME="2956"></A> that returns the inner product of two Bell states.
An array function <B>f[x,y]</B> is like an ordinary function
<B>f(x,y)</B> except that it can be used where an array is
expected.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="118" ALIGN="BOTTOM" BORDER="0"
 SRC="img68.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i2) f[x,y] := belln[x] ...
...k[0]y}:=\mathrm{belln}_{x}\cdot \mathrm{belln}_{y}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
Create a <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$4 \times 4$"></SPAN> matrix with <A NAME="tex2html32"
  HREF="http://maxima.sourceforge.net/docs/manual/en/maxima_25.html#IDX807"><B>genmatrix</B></A><SUP><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$\dagger$"></SPAN></SUP><A NAME="4809"></A>
 which maps the two dimension array <B>f</B> over the indices of the matrix with the given range.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="193" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i3) genmatrix( f , 3,3,...
...\linebreak[0]0&amp;\linebreak[0]0&amp;\linebreak[0]1\cr
}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
But instead of the named function <B>f</B> we could have used
just a function body with the 
<A NAME="tex2html33"
  HREF="http://maxima.sourceforge.net/docs/manual/en/maxima_39.html#IDX1339"><B>lambda</B></A><SUP><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$\dagger$"></SPAN></SUP><A NAME="4824"></A> function,
which returns a function that is not bound to a symbol.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="193" ALIGN="BOTTOM" BORDER="0"
 SRC="img71.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i3) genmatrix( f , 3,3,...
...\linebreak[0]0&amp;\linebreak[0]0&amp;\linebreak[0]1\cr
}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
It is obviously the <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$4 \times 4$"></SPAN> identity matrix.  The
function <B>identitymatrixp</B>(<SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img72.png"
 ALT="$mat$"></SPAN>)<A NAME="4832"></A> <A NAME="2991"></A>
 is a predicate defined in the
quantum information package in analogy to the <I>Maxima</I>
function <A NAME="tex2html34"
  HREF="http://maxima.sourceforge.net/docs/manual/en/maxima_60.html#IDX2167"><B>zeromatrixp</B></A><SUP><SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$\dagger$"></SPAN></SUP><A NAME="4837"></A>.
 It returns <B>true</B> only if its
argument is an identity matrix. (The symbol 
%
refers to the previous output.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="112" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i5) identitymatrixp(%);...
...batim}
\begin{dmath}[number={\%o5}]
\mathbf{true}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
In the following sections, we often perform these comparisons in a single line. This
is how the test appears in the regression test suite.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="112" ALIGN="BOTTOM" BORDER="0"
 SRC="img74.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i6) identitymatrixp(gen...
...batim}
\begin{dmath}[number={\%o6}]
\mathbf{true}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>
We see that these four vectors are orthonormal and thus form a basis in <!-- MATH
 $\mathbb{C}^2\otimes \mathbb{C}^2$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="44" ALIGN="MIDDLE" BORDER="0"
 SRC="img75.png"
 ALT="$\mathbb{C}^2\otimes \mathbb{C}^2$"></SPAN>.
We can also check that
<BR>
<DIV ALIGN="LEFT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
{\lvert\Psi_{00} \rangle}{\langle\Psi_{00} \rvert} +  {\lvert\Psi_{01} \rangle}{\langle\Psi_{01} \rvert}
  + {\lvert\Psi_{10} \rangle}{\langle\Psi_{10} \rvert} + {\lvert\Psi_{11} \rangle}{\langle\Psi_{11} \rvert} = \mathbb{1}_4.
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD CLASS="eqno" WIDTH=10 ALIGN="LEFT">
(<SPAN CLASS="arabic">2</SPAN>)</TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="510" HEIGHT="38" BORDER="0"
 SRC="img76.png"
 ALT="\begin{displaymath}
{\lvert\Psi_{00} \rangle}{\langle\Psi_{00} \rvert} + {\lver...
...ert\Psi_{11} \rangle}{\langle\Psi_{11} \rvert} = \mathbb{1}_4.
\end{displaymath}"></TD>
</TR></TABLE>
<BR CLEAR="ALL"></DIV><P></P>
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="112" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i2) identitymatrixp(app...
...batim}
\begin{dmath}[number={\%o2}]
\mathbf{true}\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>

<P>

<H2><A NAME="SECTION00057000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> <B>ghz</B> and  <B>ghzn</B> -- GHZ state kets<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
</H2>
<A NAME="4876"></A><A NAME="4878"></A>
The array <B>ghz</B>[<SPAN CLASS="MATH"><IMG
 WIDTH="52" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="$i,j,k$"></SPAN>] contains the GHZ kets defined by
<BR>
<DIV ALIGN="LEFT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
{\lvert\Psi_{\mbox{GHZ}}(a,b,c) \rangle} 
 = \frac{1}{\sqrt{2}} {\lvert 0,b,c \rangle} + (-1)^a  {\lvert 1,\bar b,\bar c \rangle},
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE">
<TD CLASS="eqno" WIDTH=10 ALIGN="LEFT">
(<SPAN CLASS="arabic">3</SPAN>)</TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="414" HEIGHT="56" BORDER="0"
 SRC="img79.png"
 ALT="\begin{displaymath}
{\lvert\Psi_{\mbox{GHZ}}(a,b,c) \rangle}
= \frac{1}{\sqrt...
...vert 0,b,c \rangle} + (-1)^a {\lvert 1,\bar b,\bar c \rangle},
\end{displaymath}"></TD>
</TR></TABLE>
<BR CLEAR="ALL"></DIV><P></P>
where the bar denotes the logical not operation.
The array <B>ghzn</B>[<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="$n$"></SPAN>] is the same array indexed by a single
decimal number equivalent to the binary numeration given by <SPAN CLASS="MATH"><IMG
 WIDTH="53" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img80.png"
 ALT="$a,b,c$"></SPAN>.

<P>

<H2><A NAME="SECTION00058000000000000000">
<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> <B>werner</B> -- Werner state density matrix<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$.$"></SPAN></A>
</H2>
<A NAME="4888"></A>
The Werner state is defined by 
<BR><P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<!-- MATH
 \begin{displaymath}
{\lvert\Psi(\lambda,i,j) \rangle}_{\mbox{Werner}} =
  \lambda {\lvert\Psi(i,j) \rangle}_{\mbox{Bell}}{\langle\Psi(i,j) \rvert}_{\mbox{Bell}}
   + (1-\lambda) \rho_u,
\end{displaymath}
 -->

<IMG
 WIDTH="546" HEIGHT="40" BORDER="0"
 SRC="img81.png"
 ALT="\begin{displaymath}
{\lvert\Psi(\lambda,i,j) \rangle}_{\mbox{Werner}} =
\lambd...
...{\langle\Psi(i,j) \rvert}_{\mbox{Bell}}
+ (1-\lambda) \rho_u,
\end{displaymath}">
</DIV>
<BR CLEAR="ALL">
<P></P>
where <!-- MATH
 $\rho_u=\mathbb{1}_4/4$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="96" HEIGHT="42" ALIGN="MIDDLE" BORDER="0"
 SRC="img82.png"
 ALT="$\rho_u=\mathbb{1}_4/4$"></SPAN>. The <I>qinf</I> function
is <code>werner(a,i,j)</code>.
 The entropy <A NAME="3052"></A> depends on neither <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$i$"></SPAN> nor <SPAN CLASS="MATH"><IMG
 WIDTH="15" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img83.png"
 ALT="$j$"></SPAN> and varies with <SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img84.png"
 ALT="$\lambda$"></SPAN> between
a value of <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img27.png"
 ALT="$0$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img28.png"
 ALT="$1$"></SPAN> per bit, as the state is tuned from a pure state to 
the uniform mixed state.
<BR>
<BR>
<P>
<BR>
<IMG
 WIDTH="1257" HEIGHT="520" ALIGN="BOTTOM" BORDER="0"
 SRC="img85.png"
 ALT="\begin{boxedminipage}{2.0\linewidth}
\begin{verbatim}(%i2) wxplot2d(entropy(we...
...graphics[width=.5\linewidth]{figs/werner_entropy}
\end{dmath}\end{boxedminipage}">
<BR>
<BR>
<BR>
<P>

<P>
<BR CLEAR="ALL">
<HR>
<BR><HR>
<ADDRESS>
John Lapeyre
2008-09-02
</ADDRESS>
</BODY>
</HTML>
